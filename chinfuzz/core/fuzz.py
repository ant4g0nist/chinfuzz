import os
import io
import sys
import atheris
import pathlib
import contextlib
from rich.traceback import install
# class DataType(Enum):

#     def __init__(self, fdp) -> None:
#         super().__init__()
#         # Consume unicode characters. Might contain surrogate pair characters,
#         #  which according to the specification are invalid in this situation.
#         #  However, many core software tools (e.g. Windows file paths) support them,
#         #  so other software often needs to too.
#         self.ConsumeUnicode = fdp.ConsumeUnicode
#         # Consume unicode characters, but never generate surrogate pair characters.
#         self.ConsumeUnicodeNoSurrogates = fdp.ConsumeUnicodeNoSurrogates

#         # Consume count bytes.
#         self.ConsumeBytes = fdp.ConsumeBytes

#         # Alias for Consume{Bytes,Unicode} depending on whether this is python 2 or 3
#         self.ConsumeString = fdp.ConsumeString
#         # Consumes a signed integer of the specified size (when written in two's
#         # complement notation)

#         self.ConsumeInt = fdp.ConsumeInt

#         # Consumes an unsigned integer of the specified size.
#         self.ConsumeUInt = fdp.ConsumeUInt

#         # Consumes an integer in the range [min, max].
#         self.ConsumeIntInRange = fdp.ConsumeIntInRange

#         # Consumes a list of integers of the specified size.
#         self.ConsumeIntList = fdp.ConsumeIntList

#         # Consumes a list of integers between the specified min and max.
#         self.ConsumeIntListInRange = fdp.ConsumeIntListInRange

#         # Consume an arbitrary floating-point value.
#         self.ConsumeFloat = fdp.ConsumeFloat

#         # Consume an arbitrary float, but never a special type (e.g. NaN, inf, etc.);
#         # only real numbers.
#         self.ConsumeRegularFloat = fdp.ConsumeRegularFloat

#         # Consume a float in the range [0, 1].
#         self.ConsumeProbability = fdp.ConsumeProbability

#         # Consume a float in the specified range.
#         self.ConsumeFloatInRange = fdp.ConsumeFloatInRange

#         # Consume a list of floats.
#         self.ConsumeFloatList = fdp.ConsumeFloatList

#         # Consume a list of floats that are not special type (e.g. NaN, inf, etc.)
#         self.ConsumeRegularFloatList = fdp.ConsumeRegularFloatList

#         # Consume a list of floats in the range [0, 1].
#         self.ConsumeProbabilityList = fdp.ConsumeProbabilityList

#         # Consume a list of floats in the specified range.
#         self.ConsumeFloatListInRange = fdp.ConsumeFloatListInRange

#         # Given a list, consume and return a value.
#         self.ConsumeBool = fdp.ConsumeBool

#     def __str__(self):
#         return self.value

class ChinFuzz:
    def __init__(self, args) -> None:
        self.args = args

    def getDataProvider(self, data, **kwargs):
        """
            Arguments:
                data: data generated by fuzzer
                dataType: various types of data from the arbitrary\
 bytes produced by the fuzzer.
                count: co

        """
        return atheris.FuzzedDataProvider(data)
    
    def runOneFuzzer(self):
        sys.path.append(f"fuzz")
        name = pathlib.Path(self.args.fuzz).stem
        with io.StringIO() as buff:
            with contextlib.redirect_stderr(buff):
                with atheris.instrument_imports():         
                    fuzz = __import__(name)
        
        self.callChinfuzzFuzzerTestOneInput(fuzz, self.args.fuzz)

    def callChinfuzzFuzzerTestOneInput(self, fuzz, fuzzer):
        args = [fuzzer]
        if self.args.corpus:
            args.append(self.args.corpus)

        atheris.Setup(args, fuzz.ChinfuzzFuzzerTestOneInput)
        try:
            atheris.Fuzz()
        except Exception as e:
            print(e)

    def replayFuzzerWithPoC(self):
        sys.path.append(f"fuzz")
        name = pathlib.Path(self.args.fuzz).stem
        fuzz = __import__(name)
        self.replayChinfuzzFuzzerTestOneInputPoC(fuzz, self.args.poc)

    def replayChinfuzzFuzzerTestOneInputPoC(self, fuzz, poc):
        install()

        try:
            with open(poc, 'rb') as f:
                fuzz.ChinfuzzFuzzerTestOneInput(f.read())
        
        except Exception as e:
            raise e
        
def getContractInterface(contractName, ContractInterface):
    # get contract interface.
    if os.path.exists(
        f"./build/contracts/{contractName.lower()}/step_000_cont_0_contract.tz"
    ):
        return ContractInterface.from_file(
            f"./build/contracts/{contractName.lower()}/step_000_cont_0_contract.tz"
        )

    # try to build if doesn't exist
    else:
        raise BaseException("Please compile the contracts")


def FuzzedDataProvider(data):
    return atheris.FuzzedDataProvider(data)
    
# return fdp.ConsumeUnicode(count)  
# return fdp.ConsumeUnicodeNoSurrogates(count)
# return fdp.ConsumeBytes(count)
# return fdp.ConsumeString(count)
# return fdp.ConsumeInt(count)
# return fdp.ConsumeUInt(count)
# return fdp.ConsumeIntInRange(min, max)
# return fdp.ConsumeIntList(count, bytes)
# return fdp.ConsumeIntListInRange(count, min, max)
# return fdp.ConsumeFloat(count)
# return fdp.ConsumeRegularFloat(count)
# return fdp.ConsumeProbability(count)
# return fdp.ConsumeFloatInRange(min, max)
# return fdp.ConsumeFloatList(count)
# return fdp.ConsumeRegularFloatList(count)
# return fdp.ConsumeProbabilityList(count)
# return fdp.ConsumeFloatListInRange(count, min, max)
# return fdp.ConsumeBool(count)    
